package DesignPatterns.SingletonDesignPattern;
import java.util.concurrent.atomic.AtomicInteger;

public class Singleton {
    // due to semantics of some languages, code generated by compiler can update shared variable
    // since we added "double-checking", other threads can access this "partially initialized" instance
    // "volatile" keyword ensures variable is being read from main memory & cannot be cached i.e "visibility" to all threads is same
    private static volatile Singleton instance;

    private static int instanceCount = 0;
//    private static AtomicInteger instanceCount = new AtomicInteger(0);

    private static final AtomicInteger accessAttempts = new AtomicInteger(0); // num of threads got fired to initialize instance at first
//    private static int accessAttempts = 0; (WRONG)

    private String data;

    // "private" access modifier so that we don't have access to constructor method for creating new instances
    private Singleton(String data) {
        instanceCount++;
//        instanceCount.incrementAndGet();

        this.data = data;
        System.out.println("Initialized instance with data: " + data + " by thread: " + Thread.currentThread().getName() + " after being tried by " + accessAttempts + " threads");
    }


    public static Singleton getClassInstance(String data){
        // double-checked locking ensures if instance is already created, threads should not wait here
        if(instance == null){

            accessAttempts.incrementAndGet();

            // for 1st time creation of class instance, only 1 thread is allowed in critical section i.e "mutual exclusion"
            synchronized (Singleton.class){
                if(instance == null){
                    instance = new Singleton(data);
                }
            }
        }

        return instance;
    }

    public static int getInstanceCount() {
        return instanceCount;
//        return instanceCount.get();
    }
}
